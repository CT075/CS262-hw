# Running the program

The program can be run via

```bash
# Optional
$ source path/to/virtualenv/bin/activate
$ pip install -r requirements.txt

$ python3 main.py [client|server] [hostname] [port]
```

# General design notes

The overall architecture is largely the same as [part 1](../part1/README.md).
Primary differences include using session tokens to manage user sessions, as
gRPC offers no direct session controls.

## Server changes

The largest difference is that gRPC offers no form of server-to-client
procedure call. This means that the server can no longer asynchronously send
messages to a logged-in client session and must instead rely on the client
beginning a message stream.

Session tokens are generated by the server but are not validated; a real app
would do so. Ideally, session tokens can only be correctly generated by the
server, forcing a client to first `Login`, then use the resulting token to
stream `IncomingMsgs`. Both session-specific requests (e.g. `SendMsg` and
`IncomingMsgs`) require a token.

# Endpoints

See (`chat.proto`)[chat.proto] for precise message types.

| Name         | Parameter(s) | Response      |
|--------------|--------------|---------------|
| `Create`     | `User`       | `ok` or error |
| `ListUsers`  | none         | `User list`   |
| `DeleteUser` | `User`       | `ok`          |
| `Login`      | `User`       | `SessionToken` or error |
| `IncomingMsgs`| `SessionToken` | `stream Msg` |
| `SendMsg` | `(SessionToken, str, User)` | `ok` or error |

`Create`, `ListUsers` and `DeleteUser` behave the same as in part 1. `Login`
generates a new session token and associates a session with it. As mentioned
above, as a session token can only be obtained via `Login`, `Login` must be
called before either of `IncomingMsgs` or `SendMsg`.
